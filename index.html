<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Actors As The Model For Concurrency</title>

		<meta name="description" content="A gentle introduction to actors and how they can be used to model concurrnecy">
		<meta name="author" content="John Murray">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<!-- Title -->
				<section data-markdown>
					# Actor Model
				</section>

				<!-- vanity slide -->
				<section data-markdown>
					John Murray

					Senior Software Engineer at AppNexus

					Core Web Services Team
				</section>

				<!-- overview of concurrency -->
				<section>
					<section data-markdown>
						# Concurrency
					</section>

					<section data-markdown>
						**Concurrency** - In computer science, concurrency is a property of systems 
						in which several computations are executing simultaneously, and potentially 
						interacting with each other. - _Wikipedia_
					</section>

					<section data-markdown>
						**Parallelism** - A condition that arises when at least two threads are 
						executing simultaneously. - _Sun's Multithreaded Programming Guide_
					</section>

					<section data-markdown>
						To paraphrase Adrian Mouat from Stack Overflow:

						> Concurrency is a property of a program or system and parallelism is the run-time
						> behaviour of executing multiple tasks at the same time.
					</section>

					<section data-markdown>
						This is to mean that you can achieve **concurrency** with cooperative / pre-emptive 
						multi-tasking. 

						For **parallelism** one would require multiple machines/hardware/CPUs.
					</section>
				</section>

				<!-- methods of concurrency -->
				<section>
					<section data-markdown>
						# Methods of Concurrency
					</section>

					<section data-markdown>
						## Multiple Processes

						+ Do not share memory
						+ Communicaiton typically done via message passing (e.g. writing to sockets, files, etc)
						+ Does not require synchronization or locks to communicate (although they could be used
						  if desired)
						+ Execution determined by kernel's scheduler
					</section>

					<section data-markdown>
						## Threading

						+ Shared memory
						+ Communicaiton usually done through shared memory
						+ Requires synchronizaiton and locks to communicate
						+ Execution determined by kernel's scheduler and / or _also_ the runtime's scheduler


						Note:
						Include **green threads** in this as well
					</section>
				</section>

				<!-- introduction to CSP -->
				<section>
					<section data-markdown>
						# CSP

						Communicating Sequential Processes

						Note:
						Only reason bringing it up is because you will likely read it elsewhere if you delve into this
						later on.
					</section>

					<section data-markdown>
						**CSP** - A process calculus specifically focused on interactions of concurrent systems

						**Actor Model** - A variant of CSP where "actors" are the concurrency primitive


						Note:
						Talk about how CSP is a **Mathematical Model** *or* **Calculus** for describing concurrent systems

						Mention **Go** here as well, implementation of CSP model
					</section>
				</section>

				<!-- introduction to actor model -->
				<section>
					<section data-markdown>
						# Actors
					</section>

					<section data-markdown>
						Implementations in the wild:

						+ Erlang / Elixer
						+ Akka (JVM)
						+ Orleans (.NET)
						+ Celluloid (Ruby)
						+ Pulsar (Python)


						Note:
						Just to let people understand that this is not a super obscrue concept, but something
						that is important and gaining traction or already in use by major players today.

						Notice that Erlang / Elixer are languages, the rest are frameworks. **E-Jabber-D**

						Orleans used to build backend for **Halo** multiplayer
					</section>

					<section data-markdown>
						Properties of Actors

						+ Actors are persistent
						+ Actors have a name and location (i.e. addressable)
						+ Encapsulate internal state
						+ Communicate via immutable messages
						+ Actors have supervisors and monitors
					</section>

					<section data-markdown>
						What Can / Do Actors Do?

						+ Receive messages and in response:
							+ make local decisions (e.g. alter local state)
							+ perform arbitrary, side-effecting action
							+ send messages
							+ respond to the sender 0 or more times
					</section>
					
					<section data-markdown>
						Think multiple machines, each running it's own web-service.


						Note: 
						+ can only communicate with immutable messages passing
						+ cannot CANNOT share state
					</section>
					
					<section data-markdown>
						If we were to build a web-service, what actors (components) would we likely
						include?
					</section>
					
					<section data-markdown>
						+ Request Routing
						+ Service Actors (orchestration / business logic)
						+ Authentication
						+ Auditing
						+ Metrics Colleciton
						+ Transaction Logging
						+ Cache Refreshers

						What would this look like?
					</section>

					<section data-markdown>
						![web-service-1](img/actor-model-web-service-1.png)
					</section>

					<section data-markdown>
						![web-service-2](img/actor-model-web-service-2.png)
					</section>
					
					<section data-markdown>
						![web-service-3](img/actor-model-web-service-3.png)


						Note:
						This would likely contain the business logic
					</section>
					
					<section data-markdown>
						![web-service-4](img/actor-model-web-service-4.png)


						Note:
						Can batch things up, hold open AMQP connection, separation of concerns, etc
					</section>
					
					<section data-markdown>
						![web-service-5](img/actor-model-web-service-5.png)
					</section>
					
					<section data-markdown>
						![web-service-6](img/actor-model-web-service-6.png)


						Note:
						Note the cache actor refreshing itself.

						Right? We could keep going.
					</section>

					<section data-markdown>
						![web-service-7](img/actor-model-web-service-7.png)
					</section>
				</section>

				<!-- Introduce Akka Actors -->
				<section>
					<section data-markdown>
						# Akka Actors
					</section>

					<section data-markdown>
						Info

						+ Runs on the JVM
						+ Written primarily in Scala
						+ Open Source, managed by TypeSafe, Inc.
						+ First release July, 2009
						+ Apache License 2.0
						+ Site: [akka.io](http://akka.io)
					</section>

					<section data-markdown>
						### Hello World

							class HelloActor extends Actor {
								def receive = {
									case msg: String => println(msg)
								}
							}

							// create actor (code omitted)

							helloActor ! "Hello"

					</section>

					<section data-markdown>
						### Hello-World

							class HelloActor extends Actor {
								def receive = {
									case msg: String => println(msg)
								}
							}

							// create actor (code omitted)

							helloActor ! "Hello"
							println(" World")


						Note:
						You don't know what order this is going to print out
					</section>

					<section data-markdown>
						<pre><code data-trim>
							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
								}
							}

							// create actor (code omitted)

							incActor ! 3
							incActor ! 4
							incActor ! 5
						</code></pre>
					</section>

					<section data-markdown data-transition="none">
						<pre></code data-trim>
							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
								}
							}

							// create actor (code omitted)

							incActor ! 3
							incActor ! 4
							incActor ! 5

							println(incActor.count) // => Compile Time Exception!


							Note:
							+ Talk about `ActorRef`
							+ Also mention **location transparency**
						</code></pre>
					</section>

					<section data-markdown >
						<pre></code data-trim>
							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
									case "count" => println(this.count)
								}
							}

							// create actor (code omitted)

							incActor ! 3
							incActor ! 4
							incActor ! 5

							incActor ! "count"
						</code></pre>
					</section>

					<section data-markdown >
						<pre></code data-trim>
							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
									case "getCount" => sender ! this.count
								}
							}

							// create actor (code omitted)

							incActor ! 3
							// ...

							Patterns.ask(incActor, "getCount").onSuccess {
								count => println(count)
							}
						</code></pre>


						Note:
						Data received from the actor has to be processed
						asynchronously (callbacks) because actors receive, process, and
						send messages asynchronously.
					</section>

				</section>

				<!-- Actor Lifecycle -->
				<section>
					<section data-markdown>
						# Actor Lifecycle Management
					</section>

					<section data-markdown data-background="#dddddd">
						![lifecycle management](img/actor_lifecycle.png)
					</section>
				</section>

				<!-- Actor Supervision -->
				<section>

					<section data-markdown>
						# Actor Supervision
					</section>

					<section data-markdown>
						+ All actors have a supervisor
						+ Actors can be "watched"


						Note:
						_Watch_ called the **`DeathWatch`**
					</section>

					<section data-markdown data-background="#dddddd">
						![supervisor tree](img/supervision.png)
					</section>

					<section data-markdown >
						### Supervision
						<pre></code data-trim>
							class SupervisingActor extends Actor {
								val children = (1 upto 10).map { i =>
									context.actorOf(Props.empty, "child_" + i)
								}

								override val supervisionStrategy = OneForOneStategy() {
									case ex: IOException => Resume
									case ex: DBConnectionException => Restart
									case _ => Escalate
								}

								def receive = {
									// ...
								}
							}
						</code></pre>


						Note:
						Also talk about **`AllForOneStrategy`**
					</section>

					<section data-markdown >
						### Death Watch
						<pre></code data-trim>
							class WatchActor extends Actor {
								val child = context.actorOf(Props.empty, "child")
								context.watch(child) // ALL that is needed for registration
								var lastSender = system.deadLetters
							 
								def receive = {
									case "kill" =>
										context.stop(child); lastSender = sender()
									case Terminated(`child`) => lastSender ! "finished"
								}
							}
						</code></pre>
					</section>

				</section>

				<!-- Actor Routing -->
				<section>

					<section data-markdown>
						# Actor Routing
					</section>

					<section data-markdown>
						+ `RoundRobinRoutingLogic`
						+ `RandomRoutingLogic`
						+ `SmallestMailboxRoutingLogic`
						+ `BroadcastRoutingLogic`
						+ `ScatterGatherFirstCompletedRoutingLogic`
						+ `TailChoppingRoutingLogic`
						+ `ConsistentHashingRoutingLogic`
					</section>

					<section data-markdown >
						<pre></code data-trim>
							class Master extends Actor {
								var router = {
									val routees = Vector.fill(5) {
										val r = context.actorOf(Props[Worker])
										context watch r
										ActorRefRoutee(r)
									}
									Router(RoundRobinRoutingLogic(), routees)
								}
							 
								def receive = {
									case w: Work =>
										router.route(w, sender())
									case Terminated(a) =>
										router = router.removeRoutee(a)
										val r = context.actorOf(Props[Worker])
										context watch r
										router = router.addRoutee(r)
								}
							}
						</code></pre>
					</section>

				</section>

				<!-- deployment & operations -->
				<section>

					<section data-markdown>
						# Deployment &amp; Operations
					</section>

					<section data-markdown>
						### Metrics

						+ AutoMagic like NewRelic works poorly
						+ Custom instrumentation desired for things like
							+ back pressure
							+ message throughput
							+ message time in mailbox
						+ Distributed message tracing
					</section>

					<section data-markdown>
						### Configuration &amp; Deployment

						+ Akka Remote (location transparancy)
						+ Akka Cluster
						+ No LBs for stateful communication
						+ Runs stand-alone (not in container)


						Note:
						+ Akka contains persistent connection to the other actor-system
						+ Using **phi accrual failure detector**
					</section>

				</section>

				<!-- Additional Resources -->
				<section>
					<section data-markdown>
						## Additional Resources

						+ [akka.io](http://akka.io)
						+ [examples](https://github.com/JohnMurray/learn-scala-worksheets)
						+ [scala-exercises.47deg.com/](http://scala-exercises.47deg.com/)
					</section>

					<section data-markdown>
						### These Slides

						[github.com/JohnMurray/actor-based-concurrency-presentation](https://github.com/JohnMurray/actor-based-concurrency-presentation)
					</section>
				</section>


				<!-- contact slide -->
				<section style="text-align:center;">
					<div style="text-align:left;margin:0 auto;display:inline-block;">
						<p>
							<span style="width:180px; display:inline-block;">Twitter:</span>
							<a href="http://twitter.com/johnmurray_io">@johnmurray_io</a>
						</p>
						<p>
							<span style="width:180px; display:inline-block;">Email:</span>
							<a href="mailto:johnmurray@appnexus.com">johnmurray@appnexus.com</a>
						</p>
						<p>
							<span style="width:180px; display:inline-block;">GitHub:</span>
							<a href="http://github.com/JohnMurray">github.com/JohnMurray</a>
						</p>
					</div>
				</section>
			</div>


		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
