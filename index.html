<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Actors As The Model For Concurrency</title>

		<meta name="description" content="A gentle introduction to actors and how they can be used to model concurrnecy">
		<meta name="author" content="John Murray">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<!-- Title -->
				<section data-markdown>
					# Actor Model
				</section>

				<!-- Talk Plan -->
				<section data-markdown>
					# The Plan

					+ Theory
					+ Practical Usage
					+ Example and Further Study
				</section>

				<!-- Theory -->
				<section data-markdown>
					# Theory
				</section>

					<!-- Theory - Description / Definition -->
					<section>
						<section data-markdown>
							## Actor Model

							A method of concurrency in which the universal primitive is an actor
						</section>
						<section data-markdown>
							## Other Concurrency Models

							+ Process-based concurrency
							+ Thread-based concurrency
						</section>
					</section>

					<!-- Theory - Actor Description / Definition -->
					<section>
						<section data-markdown>
							## Actors
						</section>

						<section>
							<h2>Properties of Actors</h2>

							<ul>
								<li class="fragment">Actors are persistent</li>
								<li class="fragment">Encapsulate internal state</li>
								<li class="fragment">Actors are asynchronous</li>
								<li class="fragment">Create new actors</li>
							</ul>
						</section>
						<section>
							<h2>What Can Actors</h2>
							<ul>
								<li class="fragment">
									Receive messages and in response:
									<ul>
										<li class="fragment">make local decisions (e.g. alter local state)</li>
										<li class="fragment">perform arbitrary, side-effecting action</li>
										<li class="fragment">send messages</li>
										<li class="fragment">respond to the sender 0 or more times</li>
									</ul>
								</li>
								<li class="fragment">Process exactly one message at a time</li>
							</ul>

						</section>
						<section>
							<h2>Actors</h2>

							<blockquote style="width:90%">
								Do not communicate by sharing memory; instead, share 
								memory by communicating.
							</blockquote>

							<span style="text-align:right;display:block;width:95%;">
								&dash;
								<a href="https://golang.org/doc/effective_go.html">Effective Go</a>
							</span>
						</section>
					</section>

					<!-- Theory - Actor Communication -->
					<section>
						<section data-markdown>
							## Actor Communication
						</section>

						<!-- Communication Properties -->
						<section>
							<h2>Properties of Communication</h2>

							<ul>
								<li class="fragment">No channels or intermediaries (such as in CSP)</li>
								<li class="fragment">"Best Effort" delivery</li>
								<li class="fragment">At-most-once delivery</li>
								<li class="fragment">Messages can take arbitrary long to be delivered</li>
								<li class="fragment">No message ordering guarantees</li>
							</ul>
						</section>

						<!-- Addresses -->
						<section>
							<h2>Address</h2>

							<ul>
								<li class="fragment">Identifies an Actor</li>
								<li class="fragment">May also represent a proxy / forwarder to an Actor</li>
								<li class="fragment">Contains location and transport information</li>
								<li class="fragment">Location transparency</li>
							</ul>
						</section>
						<section>
							<h2>Address</h2>

							<ul>
								<li class="fragment">Many to many relationship between actors and addresses</li>
								<li class="fragment">One address may represent many actors (pool)</li>
								<li class="fragment">One actor may have many addresses</li>
							</ul>
						</section>
					</section>

					<!-- Theory - Living with Failure -->
					<section>
						<section data-markdown>
							## Handling Failure
						</section>
						<section data-markdown>
							## Supervision

							The running state of an actor is monitored and managed by another
							actor (the _Supervisor_)
						</section>
						<section data-markdown>
							## Properties of Supervision

							+ Constantly monitors running state of actor
							+ Can perform actions based on the state of the actor (e.g. unhandled error)
							+ Can stop/kill or restart supervised actors
						</section>
						<section data-markdown>
							## Supervision Trees

							![supervisor tree](img/supervision.png)
						</section>
						<section data-markdown>
							## Transparent Lifecycle Management

							+ Addresses do not change during restarts
							+ Mailboxes are persisted outside the actor instances
						</section>

					</section>



				<!-- Practical Usage -->
				<section data-markdown>
					# Practical Usage
				</section>

					<section>
						<section data-markdown>
							## Checking Account

							+ A shared account balance
							+ Multiple, simultaneous withdrawls
							+ Requires coordination / locking to ensure account is not overdrawn
						</section>

						<section data-markdown>
							## Checking Account

							+ Current balance of <pre>$80</pre>
							+ Person A wishes to withdrawl <pre>$60</pre>
							+ Person B wishes to withdrawl <pre>$50</pre>
						</section>

						<section data-markdown>
							## Checking Account

								currentBal = Checking.balance;
								if( currentBal > withdrawlAmt ) {
									Checking.balance -= withdrawlAmt;
									return true;
								} else {
									return false;
								}
						</section>

						<section data-markdown>
							## Checking Account

							    actor Checking {
							        var balance = 80

								    def receive = {
									    case Withdrawl(amt) =>
									    	if( balance > amt ) {
										    	balance -= amt
										    	sender sendMsg true
										    } else {
											    sender sendMsg false
											}
									}
								}
						</section>

						<section data-markdown>
							## Checking Account

								// send message to withdrawl 60 dollars
							    Checking sendMsg Withdrawl(60)

								// send message to withdrawl 50 dollars
							    Checking sendMsg Withdrawl(50)
						</section>
					</section>

					<section>
						<h2>Actor Use-Cases</h2>

						<ul>
							<li class="fragment">Processing pipeline</li>
							<li class="fragment">Streaming data</li>
							<li class="fragment">Multi-user concurrency</li>
							<li class="fragment">Systems high uptime requirements (Ericsson)</li>
							<li class="fragment">Concurrent Applications</li>
						</ul>
					</section>

					<section data-markdown>
						## Frameworks / Languages

						+ Erlang / Elixer
						+ Akka (JVM)
						+ Orleans (.NET)
						+ Celluloid (Ruby)
						+ Pulsar (Python)
					</section>

				<!-- vanity slide -->
				<section>
					<h3>John Murray</h3>

					<p style="text-align: left;">
						johnmurray at appnexus dot com <br />
						<img src="/img/twitter.ping" /><a href="">@johnmurray_io</a> <br />
						<a href="">johnmurray</a>
					</p>
				</section>










					<section data-markdown>
						What Can / Do Actors Do?

					</section>
					
					<section data-markdown>
						Think multiple machines, each running it's own web-service.


						Note: 
						+ can only communicate with immutable messages passing
						+ cannot CANNOT share state
					</section>
					
					<section data-markdown>
						If we were to build a web-service, what actors (components) would we likely
						include?
					</section>
					
					<section data-markdown>
						+ Request Routing
						+ Service Actors (orchestration / business logic)
						+ Authentication
						+ Auditing
						+ Metrics Colleciton
						+ Transaction Logging
						+ Cache Refreshers

						What would this look like?
					</section>

					<section data-markdown>
						![web-service-1](img/actor-model-web-service-1.png)
					</section>

					<section data-markdown>
						![web-service-2](img/actor-model-web-service-2.png)
					</section>
					
					<section data-markdown>
						![web-service-3](img/actor-model-web-service-3.png)


						Note:
						This would likely contain the business logic
					</section>
					
					<section data-markdown>
						![web-service-4](img/actor-model-web-service-4.png)


						Note:
						Can batch things up, hold open AMQP connection, separation of concerns, etc
					</section>
					
					<section data-markdown>
						![web-service-5](img/actor-model-web-service-5.png)
					</section>
					
					<section data-markdown>
						![web-service-6](img/actor-model-web-service-6.png)


						Note:
						Note the cache actor refreshing itself.

						Right? We could keep going.
					</section>

					<section data-markdown>
						![web-service-7](img/actor-model-web-service-7.png)
					</section>
				</section>

				<!-- Introduce Akka Actors -->
				<section>
					<section data-markdown>
						# Akka Actors
					</section>

					<section data-markdown>
						Info

						+ Runs on the JVM
						+ Written primarily in Scala
						+ Open Source, managed by TypeSafe, Inc.
						+ First release July, 2009
						+ Apache License 2.0
						+ Site: [akka.io](http://akka.io)
					</section>

					<section data-markdown>
						### Hello World

							class HelloActor extends Actor {
								def receive = {
									case msg: String => println(msg)
								}
							}

							// create actor (code omitted)

							helloActor ! "Hello"

					</section>

					<section data-markdown>
						### Hello-World

							class HelloActor extends Actor {
								def receive = {
									case msg: String => println(msg)
								}
							}

							// create actor (code omitted)

							helloActor ! "Hello"
							println(" World")


						Note:
						You don't know what order this is going to print out
					</section>

					<section data-markdown>
						<pre><code data-trim>
							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
								}
							}

							// create actor (code omitted)

							incActor ! 3
							incActor ! 4
							incActor ! 5
						</code></pre>
					</section>

					<section data-markdown data-transition="none">
						<pre></code data-trim>
							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
								}
							}

							// create actor (code omitted)

							incActor ! 3
							incActor ! 4
							incActor ! 5

							println(incActor.count) // => Compile Time Exception!


							Note:
							+ Talk about `ActorRef`
							+ Also mention **location transparency**
						</code></pre>
					</section>

					<section data-markdown >
						<pre></code data-trim>
							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
									case "count" => println(this.count)
								}
							}

							// create actor (code omitted)

							incActor ! 3
							incActor ! 4
							incActor ! 5

							incActor ! "count"
						</code></pre>
					</section>

					<section data-markdown >
						<pre></code data-trim>
							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
									case "getCount" => sender ! this.count
								}
							}

							// create actor (code omitted)

							incActor ! 3
							// ...

							Patterns.ask(incActor, "getCount").onSuccess {
								count => println(count)
							}
						</code></pre>


						Note:
						Data received from the actor has to be processed
						asynchronously (callbacks) because actors receive, process, and
						send messages asynchronously.
					</section>

				</section>

				<!-- Actor Lifecycle -->
				<section>
					<section data-markdown>
						# Actor Lifecycle Management
					</section>

					<section data-markdown data-background="#dddddd">
						![lifecycle management](img/actor_lifecycle.png)
					</section>
				</section>

				<!-- Actor Supervision -->
				<section>

					<section data-markdown>
						# Actor Supervision
					</section>

					<section data-markdown>
						+ All actors have a supervisor
						+ Actors can be "watched"


						Note:
						_Watch_ called the **`DeathWatch`**
					</section>

					<section data-markdown data-background="#dddddd">
						![supervisor tree](img/supervision.png)
					</section>

					<section data-markdown >
						### Supervision
						<pre></code data-trim>
							class SupervisingActor extends Actor {
								val children = (1 upto 10).map { i =>
									context.actorOf(Props.empty, "child_" + i)
								}

								override val supervisionStrategy = OneForOneStategy() {
									case ex: IOException => Resume
									case ex: DBConnectionException => Restart
									case _ => Escalate
								}

								def receive = {
									// ...
								}
							}
						</code></pre>


						Note:
						Also talk about **`AllForOneStrategy`**
					</section>

					<section data-markdown >
						### Death Watch
						<pre></code data-trim>
							class WatchActor extends Actor {
								val child = context.actorOf(Props.empty, "child")
								context.watch(child) // ALL that is needed for registration
								var lastSender = system.deadLetters
							 
								def receive = {
									case "kill" =>
										context.stop(child); lastSender = sender()
									case Terminated(`child`) => lastSender ! "finished"
								}
							}
						</code></pre>
					</section>

				</section>

				<!-- Actor Routing -->
				<section>

					<section data-markdown>
						# Actor Routing
					</section>

					<section data-markdown>
						+ `RoundRobinRoutingLogic`
						+ `RandomRoutingLogic`
						+ `SmallestMailboxRoutingLogic`
						+ `BroadcastRoutingLogic`
						+ `ScatterGatherFirstCompletedRoutingLogic`
						+ `TailChoppingRoutingLogic`
						+ `ConsistentHashingRoutingLogic`
					</section>

					<section data-markdown >
						<pre></code data-trim>
							class Master extends Actor {
								var router = {
									val routees = Vector.fill(5) {
										val r = context.actorOf(Props[Worker])
										context watch r
										ActorRefRoutee(r)
									}
									Router(RoundRobinRoutingLogic(), routees)
								}
							 
								def receive = {
									case w: Work =>
										router.route(w, sender())
									case Terminated(a) =>
										router = router.removeRoutee(a)
										val r = context.actorOf(Props[Worker])
										context watch r
										router = router.addRoutee(r)
								}
							}
						</code></pre>
					</section>

				</section>

				<!-- deployment & operations -->
				<section>

					<section data-markdown>
						# Deployment &amp; Operations
					</section>

					<section data-markdown>
						### Metrics

						+ AutoMagic like NewRelic works poorly
						+ Custom instrumentation desired for things like
							+ back pressure
							+ message throughput
							+ message time in mailbox
						+ Distributed message tracing
					</section>

					<section data-markdown>
						### Configuration &amp; Deployment

						+ Akka Remote (location transparancy)
						+ Akka Cluster
						+ No LBs for stateful communication
						+ Runs stand-alone (not in container)


						Note:
						+ Akka contains persistent connection to the other actor-system
						+ Using **phi accrual failure detector**
					</section>

				</section>

				<!-- Additional Resources -->
				<section>
					<section data-markdown>
						## Additional Resources

						+ [akka.io](http://akka.io)
						+ [examples](https://github.com/JohnMurray/learn-scala-worksheets)
						+ [scala-exercises.47deg.com/](http://scala-exercises.47deg.com/)
					</section>

					<section data-markdown>
						### These Slides

						[github.com/JohnMurray/actor-based-concurrency-presentation](https://github.com/JohnMurray/actor-based-concurrency-presentation)
					</section>
				</section>


				<!-- contact slide -->
				<section style="text-align:center;">
					<div style="text-align:left;margin:0 auto;display:inline-block;">
						<p>
							<span style="width:180px; display:inline-block;">Twitter:</span>
							<a href="http://twitter.com/johnmurray_io">@johnmurray_io</a>
						</p>
						<p>
							<span style="width:180px; display:inline-block;">Email:</span>
							<a href="mailto:johnmurray@appnexus.com">johnmurray@appnexus.com</a>
						</p>
						<p>
							<span style="width:180px; display:inline-block;">GitHub:</span>
							<a href="http://github.com/JohnMurray">github.com/JohnMurray</a>
						</p>
					</div>
				</section>
			</div>


		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
